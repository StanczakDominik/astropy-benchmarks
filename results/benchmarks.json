{
    "coordinates.FrameBenchmarks.time_init_array": {
        "code": "class FrameBenchmarks:\n    def time_init_array(self):\n        FK5(self.array_ra, self.array_dec)\n\n    def setup(self):\n    \n        self.scalar_ra = 3.2 * u.deg\n        self.scalar_dec = 2.2 * u.deg\n    \n        self.array_ra = np.linspace(0., 360., 1000) * u.deg\n        self.array_dec = np.linspace(-90., 90., 1000) * u.deg",
        "name": "coordinates.FrameBenchmarks.time_init_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c674b97d5a26e5c61c240678ebdcc4a8fbb346db4aacedbb7868aefb3230f080",
        "warmup_time": -1
    },
    "coordinates.FrameBenchmarks.time_init_nodata": {
        "code": "class FrameBenchmarks:\n    def time_init_nodata(self):\n        FK5()\n\n    def setup(self):\n    \n        self.scalar_ra = 3.2 * u.deg\n        self.scalar_dec = 2.2 * u.deg\n    \n        self.array_ra = np.linspace(0., 360., 1000) * u.deg\n        self.array_dec = np.linspace(-90., 90., 1000) * u.deg",
        "name": "coordinates.FrameBenchmarks.time_init_nodata",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c3d603a1d100c4d8f50750ddfac91c7db732186bbe5091b354ab1ee7bd4703d5",
        "warmup_time": -1
    },
    "coordinates.FrameBenchmarks.time_init_scalar": {
        "code": "class FrameBenchmarks:\n    def time_init_scalar(self):\n        FK5(self.scalar_ra, self.scalar_dec)\n\n    def setup(self):\n    \n        self.scalar_ra = 3.2 * u.deg\n        self.scalar_dec = 2.2 * u.deg\n    \n        self.array_ra = np.linspace(0., 360., 1000) * u.deg\n        self.array_dec = np.linspace(-90., 90., 1000) * u.deg",
        "name": "coordinates.FrameBenchmarks.time_init_scalar",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "defe667485d7109897f4a6a2770d80eb89ff9295c31bc941252bf4b8f6e15288",
        "warmup_time": -1
    },
    "coordinates.SkyCoordBenchmarks.time_icrs_to_galactic_array": {
        "code": "class SkyCoordBenchmarks:\n    def time_icrs_to_galactic_array(self):\n        self.coord_array_2.transform_to('galactic')\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones(1000), np.ones(1000)\n        self.coord_array_1 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones(1000000), np.ones(1000000)\n        self.coord_array_2 = SkyCoord(lon, lat, unit='deg', frame='icrs')",
        "name": "coordinates.SkyCoordBenchmarks.time_icrs_to_galactic_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "03a8d659ce76024b25427f931b691a4cdd160fa0aeb99e0b9f6c8831df6a832b",
        "warmup_time": -1
    },
    "coordinates.SkyCoordBenchmarks.time_icrs_to_galactic_scalar": {
        "code": "class SkyCoordBenchmarks:\n    def time_icrs_to_galactic_scalar(self):\n        self.coord_scalar.transform_to('galactic')\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones(1000), np.ones(1000)\n        self.coord_array_1 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones(1000000), np.ones(1000000)\n        self.coord_array_2 = SkyCoord(lon, lat, unit='deg', frame='icrs')",
        "name": "coordinates.SkyCoordBenchmarks.time_icrs_to_galactic_scalar",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "50cb34073decb62c5e47dc358fa84c4496c41a70eedc12d430de14dd6b2eaca7",
        "warmup_time": -1
    },
    "coordinates.SkyCoordBenchmarks.time_init_array": {
        "code": "class SkyCoordBenchmarks:\n    def time_init_array(self):\n        N = int(1e6)\n        lon, lat = np.ones(N), np.ones(N)\n        SkyCoord(lon, lat, unit='deg', frame='icrs')\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones(1000), np.ones(1000)\n        self.coord_array_1 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones(1000000), np.ones(1000000)\n        self.coord_array_2 = SkyCoord(lon, lat, unit='deg', frame='icrs')",
        "name": "coordinates.SkyCoordBenchmarks.time_init_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "efd1c95143b17aa70b359c057d501cf1f21c675354fc145e7362fad20e746143",
        "warmup_time": -1
    },
    "coordinates.SkyCoordBenchmarks.time_init_scalar": {
        "code": "class SkyCoordBenchmarks:\n    def time_init_scalar(self):\n        SkyCoord(1, 2, unit='deg', frame='icrs')\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones(1000), np.ones(1000)\n        self.coord_array_1 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones(1000000), np.ones(1000000)\n        self.coord_array_2 = SkyCoord(lon, lat, unit='deg', frame='icrs')",
        "name": "coordinates.SkyCoordBenchmarks.time_init_scalar",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "72be933df1c75170846adad4c31fa6b2034a6061a7af30a127e14b9599b468a5",
        "warmup_time": -1
    },
    "coordinates.SkyCoordBenchmarks.time_iter_array": {
        "code": "class SkyCoordBenchmarks:\n    def time_iter_array(self):\n        for c in self.coord_array_1:\n            pass\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones(1000), np.ones(1000)\n        self.coord_array_1 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones(1000000), np.ones(1000000)\n        self.coord_array_2 = SkyCoord(lon, lat, unit='deg', frame='icrs')",
        "name": "coordinates.SkyCoordBenchmarks.time_iter_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6bf1ec9b68eb8af4cf3dff787c3e22c9c549ce973d4d29c025175379b6275fec",
        "warmup_time": -1
    },
    "coordinates.SkyCoordBenchmarks.time_repr_array": {
        "code": "class SkyCoordBenchmarks:\n    def time_repr_array(self):\n        repr(self.coord_array_1)\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones(1000), np.ones(1000)\n        self.coord_array_1 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones(1000000), np.ones(1000000)\n        self.coord_array_2 = SkyCoord(lon, lat, unit='deg', frame='icrs')",
        "name": "coordinates.SkyCoordBenchmarks.time_repr_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "441c7f643c000bea0aae55a16a88d01a8a89b91cbf3f3c080945963a3d85a914",
        "warmup_time": -1
    },
    "coordinates.SkyCoordBenchmarks.time_repr_scalar": {
        "code": "class SkyCoordBenchmarks:\n    def time_repr_scalar(self):\n        repr(self.coord_scalar)\n\n    def setup(self):\n    \n        self.coord_scalar = SkyCoord(1, 2, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones(1000), np.ones(1000)\n        self.coord_array_1 = SkyCoord(lon, lat, unit='deg', frame='icrs')\n    \n        lon, lat = np.ones(1000000), np.ones(1000000)\n        self.coord_array_2 = SkyCoord(lon, lat, unit='deg', frame='icrs')",
        "name": "coordinates.SkyCoordBenchmarks.time_repr_scalar",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9144e2f52d729a4ec838dcce3d3f15bbec89a3b187a26affc5feb41e59fb91d1",
        "warmup_time": -1
    },
    "coordinates.time_angle_array_repr": {
        "code": "def time_angle_array_repr():\n    # Prior to Astropy 3.0, this was very inefficient\n    repr(ANGLES)",
        "name": "coordinates.time_angle_array_repr",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f7358d7eaaa2c43a08c409093a9da4c8824ee2c56f680a47906562bb1ce67d7c",
        "warmup_time": -1
    },
    "coordinates.time_angle_array_repr_latex": {
        "code": "def time_angle_array_repr_latex():\n    # Prior to Astropy 3.0, this was very inefficient\n    ANGLES._repr_latex_()",
        "name": "coordinates.time_angle_array_repr_latex",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d791293d91b6bf48d25ec937a4650655e13e232dd2136182811357cc4641fdef",
        "warmup_time": -1
    },
    "coordinates.time_angle_array_str": {
        "code": "def time_angle_array_str():\n    # Prior to Astropy 3.0, this was very inefficient\n    str(ANGLES)",
        "name": "coordinates.time_angle_array_str",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "bb01074796e6a03b8b0c30b44045048769af753ecbe7b2ec8bf460be6bb73160",
        "warmup_time": -1
    },
    "coordinates.time_latitude": {
        "code": "def time_latitude():\n    Latitude(3.2, u.degree)",
        "name": "coordinates.time_latitude",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d37e722e0c0f585281e1f368dc32f3943dd8cf1ec4009924181467dd2c3a6cd0",
        "warmup_time": -1
    },
    "cosmology.LambdaCDMBenchmarks.time_age": {
        "code": "class LambdaCDMBenchmarks:\n    def time_age(self, cosmo):\n        self.cosmology.age(self.test_zs)\n\n    def setup(self, cosmo):\n        self.cosmology = cosmo\n        self.test_zs = np.linspace(0.1, 5.0, 200)",
        "name": "cosmology.LambdaCDMBenchmarks.time_age",
        "number": 0,
        "param_names": [
            "param1"
        ],
        "params": [
            [
                "LambdaCDM(H0=65 km / (Mpc s), Om0=0.6, Ode0=0.7, Tcmb0=0 K, Neff=3.04, m_nu=None, Ob0=None)",
                "LambdaCDM(H0=65 km / (Mpc s), Om0=0.25, Ode0=0.65, Tcmb0=2.7 K, Neff=3.04, m_nu=[ 0.  0.  0.] eV, Ob0=None)",
                "LambdaCDM(H0=65 km / (Mpc s), Om0=0.6, Ode0=0.7, Tcmb0=2.7 K, Neff=4, m_nu=[ 0.  0.  0.  0.] eV, Ob0=None)",
                "LambdaCDM(H0=65 km / (Mpc s), Om0=0.4, Ode0=0.2, Tcmb0=2.7 K, Neff=3.04, m_nu=[ 0.  0.  0.] eV, Ob0=None)",
                "FlatLambdaCDM(H0=65 km / (Mpc s), Om0=0.25, Tcmb0=0 K, Neff=3.04, m_nu=None, Ob0=None)",
                "FlatLambdaCDM(H0=65 km / (Mpc s), Om0=0.25, Tcmb0=2.7 K, Neff=3.04, m_nu=[ 0.  0.  0.] eV, Ob0=None)",
                "FlatLambdaCDM(H0=65 km / (Mpc s), Om0=0.25, Tcmb0=2.7 K, Neff=3.04, m_nu=[ 0.05  0.1   0.15] eV, Ob0=None)"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9d18698d04bfa5d55ddcae0f12ee69266bfed44f4b0fd81018487132da078301",
        "warmup_time": -1
    },
    "cosmology.LambdaCDMBenchmarks.time_lumdist": {
        "code": "class LambdaCDMBenchmarks:\n    def time_lumdist(self, cosmo):\n        self.cosmology.luminosity_distance(self.test_zs)\n\n    def setup(self, cosmo):\n        self.cosmology = cosmo\n        self.test_zs = np.linspace(0.1, 5.0, 200)",
        "name": "cosmology.LambdaCDMBenchmarks.time_lumdist",
        "number": 0,
        "param_names": [
            "param1"
        ],
        "params": [
            [
                "LambdaCDM(H0=65 km / (Mpc s), Om0=0.6, Ode0=0.7, Tcmb0=0 K, Neff=3.04, m_nu=None, Ob0=None)",
                "LambdaCDM(H0=65 km / (Mpc s), Om0=0.25, Ode0=0.65, Tcmb0=2.7 K, Neff=3.04, m_nu=[ 0.  0.  0.] eV, Ob0=None)",
                "LambdaCDM(H0=65 km / (Mpc s), Om0=0.6, Ode0=0.7, Tcmb0=2.7 K, Neff=4, m_nu=[ 0.  0.  0.  0.] eV, Ob0=None)",
                "LambdaCDM(H0=65 km / (Mpc s), Om0=0.4, Ode0=0.2, Tcmb0=2.7 K, Neff=3.04, m_nu=[ 0.  0.  0.] eV, Ob0=None)",
                "FlatLambdaCDM(H0=65 km / (Mpc s), Om0=0.25, Tcmb0=0 K, Neff=3.04, m_nu=None, Ob0=None)",
                "FlatLambdaCDM(H0=65 km / (Mpc s), Om0=0.25, Tcmb0=2.7 K, Neff=3.04, m_nu=[ 0.  0.  0.] eV, Ob0=None)",
                "FlatLambdaCDM(H0=65 km / (Mpc s), Om0=0.25, Tcmb0=2.7 K, Neff=3.04, m_nu=[ 0.05  0.1   0.15] eV, Ob0=None)"
            ]
        ],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5bac457205366118e159292716591c45c0cfc49c2e2729149b83abfbb3e6ed3e",
        "warmup_time": -1
    },
    "io_ascii.core.CoreSuite.time_base_splitter": {
        "code": "class CoreSuite:\n    def time_base_splitter(self):\n        core.BaseSplitter().process_val(self.line)\n\n    def setup(self):\n        self.lines = []\n        options = [['a b c d'], ['a b c \\\\', 'd'], ['a b \\\\', 'c \\\\', 'd'],\n                   ['a b \\\\', 'c d'], ['a \\\\', 'b c \\\\', 'd']]\n        for i in range(1000):\n            self.lines.extend(options[i % 5])\n        options = ['\"a\\tbc\\t\\td\"', 'ab cd', '\\tab\\t\\tc\\td', 'a \\tb \\tcd']\n        self.line = ''.join([options[i % 4] for i in range(1000)])\n        self.vals = [randword() for i in range(1000)]\n        self.csv_line = ','.join([str(x) for x in self.vals])\n        lst = []\n        lst.append([random.randint(-500, 500) for i in range(1000)])\n        lst.append([random.random() * 500 - 500 for i in range(1000)])\n        lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, lst):\n            col.str_vals = [str(s) for s in x]",
        "name": "io_ascii.core.CoreSuite.time_base_splitter",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ef95250cdacbcad30d437c583c0005f2e0f100ed28e242aea22dfd55507626f2",
        "warmup_time": -1
    },
    "io_ascii.core.CoreSuite.time_continuation_inputter": {
        "code": "class CoreSuite:\n    def time_continuation_inputter(self):\n        core.ContinuationLinesInputter().process_lines(self.lines)\n\n    def setup(self):\n        self.lines = []\n        options = [['a b c d'], ['a b c \\\\', 'd'], ['a b \\\\', 'c \\\\', 'd'],\n                   ['a b \\\\', 'c d'], ['a \\\\', 'b c \\\\', 'd']]\n        for i in range(1000):\n            self.lines.extend(options[i % 5])\n        options = ['\"a\\tbc\\t\\td\"', 'ab cd', '\\tab\\t\\tc\\td', 'a \\tb \\tcd']\n        self.line = ''.join([options[i % 4] for i in range(1000)])\n        self.vals = [randword() for i in range(1000)]\n        self.csv_line = ','.join([str(x) for x in self.vals])\n        lst = []\n        lst.append([random.randint(-500, 500) for i in range(1000)])\n        lst.append([random.random() * 500 - 500 for i in range(1000)])\n        lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, lst):\n            col.str_vals = [str(s) for s in x]",
        "name": "io_ascii.core.CoreSuite.time_continuation_inputter",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "406566039a7c4a88ddbba6da758e5757bc52acdbf7fe159d5324696a33b7f960",
        "warmup_time": -1
    },
    "io_ascii.core.CoreSuite.time_convert_vals": {
        "code": "class CoreSuite:\n    def time_convert_vals(self):\n        core.TableOutputter()._convert_vals(self.cols)\n\n    def setup(self):\n        self.lines = []\n        options = [['a b c d'], ['a b c \\\\', 'd'], ['a b \\\\', 'c \\\\', 'd'],\n                   ['a b \\\\', 'c d'], ['a \\\\', 'b c \\\\', 'd']]\n        for i in range(1000):\n            self.lines.extend(options[i % 5])\n        options = ['\"a\\tbc\\t\\td\"', 'ab cd', '\\tab\\t\\tc\\td', 'a \\tb \\tcd']\n        self.line = ''.join([options[i % 4] for i in range(1000)])\n        self.vals = [randword() for i in range(1000)]\n        self.csv_line = ','.join([str(x) for x in self.vals])\n        lst = []\n        lst.append([random.randint(-500, 500) for i in range(1000)])\n        lst.append([random.random() * 500 - 500 for i in range(1000)])\n        lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, lst):\n            col.str_vals = [str(s) for s in x]",
        "name": "io_ascii.core.CoreSuite.time_convert_vals",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0c660365b4b3180a53e83e7b346bbb72270cbb17c23a7b9c343b9e62bd6be16d",
        "warmup_time": -1
    },
    "io_ascii.core.CoreSuite.time_default_splitter_call": {
        "code": "class CoreSuite:\n    def time_default_splitter_call(self):\n        core.DefaultSplitter()(self.csv_line)\n\n    def setup(self):\n        self.lines = []\n        options = [['a b c d'], ['a b c \\\\', 'd'], ['a b \\\\', 'c \\\\', 'd'],\n                   ['a b \\\\', 'c d'], ['a \\\\', 'b c \\\\', 'd']]\n        for i in range(1000):\n            self.lines.extend(options[i % 5])\n        options = ['\"a\\tbc\\t\\td\"', 'ab cd', '\\tab\\t\\tc\\td', 'a \\tb \\tcd']\n        self.line = ''.join([options[i % 4] for i in range(1000)])\n        self.vals = [randword() for i in range(1000)]\n        self.csv_line = ','.join([str(x) for x in self.vals])\n        lst = []\n        lst.append([random.randint(-500, 500) for i in range(1000)])\n        lst.append([random.random() * 500 - 500 for i in range(1000)])\n        lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, lst):\n            col.str_vals = [str(s) for s in x]",
        "name": "io_ascii.core.CoreSuite.time_default_splitter_call",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9b11dacb692c8e31688afc0031aa584030b2b4311f16ab0de8e61d1111f68568",
        "warmup_time": -1
    },
    "io_ascii.core.CoreSuite.time_default_splitter_join": {
        "code": "class CoreSuite:\n    def time_default_splitter_join(self):\n        core.DefaultSplitter().join(self.vals)\n\n    def setup(self):\n        self.lines = []\n        options = [['a b c d'], ['a b c \\\\', 'd'], ['a b \\\\', 'c \\\\', 'd'],\n                   ['a b \\\\', 'c d'], ['a \\\\', 'b c \\\\', 'd']]\n        for i in range(1000):\n            self.lines.extend(options[i % 5])\n        options = ['\"a\\tbc\\t\\td\"', 'ab cd', '\\tab\\t\\tc\\td', 'a \\tb \\tcd']\n        self.line = ''.join([options[i % 4] for i in range(1000)])\n        self.vals = [randword() for i in range(1000)]\n        self.csv_line = ','.join([str(x) for x in self.vals])\n        lst = []\n        lst.append([random.randint(-500, 500) for i in range(1000)])\n        lst.append([random.random() * 500 - 500 for i in range(1000)])\n        lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, lst):\n            col.str_vals = [str(s) for s in x]",
        "name": "io_ascii.core.CoreSuite.time_default_splitter_join",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "306bb839233283dd45a91d2646131b786fecc79198f55c91a843d8d05bbf062a",
        "warmup_time": -1
    },
    "io_ascii.core.CoreSuite.time_whitespace_splitter": {
        "code": "class CoreSuite:\n    def time_whitespace_splitter(self):\n        core.WhitespaceSplitter().process_line(self.line)\n\n    def setup(self):\n        self.lines = []\n        options = [['a b c d'], ['a b c \\\\', 'd'], ['a b \\\\', 'c \\\\', 'd'],\n                   ['a b \\\\', 'c d'], ['a \\\\', 'b c \\\\', 'd']]\n        for i in range(1000):\n            self.lines.extend(options[i % 5])\n        options = ['\"a\\tbc\\t\\td\"', 'ab cd', '\\tab\\t\\tc\\td', 'a \\tb \\tcd']\n        self.line = ''.join([options[i % 4] for i in range(1000)])\n        self.vals = [randword() for i in range(1000)]\n        self.csv_line = ','.join([str(x) for x in self.vals])\n        lst = []\n        lst.append([random.randint(-500, 500) for i in range(1000)])\n        lst.append([random.random() * 500 - 500 for i in range(1000)])\n        lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, lst):\n            col.str_vals = [str(s) for s in x]",
        "name": "io_ascii.core.CoreSuite.time_whitespace_splitter",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ab9241b763369886db83aff56a4a41a13296bdc6de02fd6cca426503e4195b81",
        "warmup_time": -1
    },
    "io_ascii.fixedwidth.FixedWidthSuite.time_header": {
        "code": "class FixedWidthSuite:\n    def time_header(self):\n        self.header.get_cols(self.lines)\n\n    def setup(self):\n        self.header = ascii.FixedWidthHeader()\n        self.header.start_line = 0\n        self.header.col_starts = None\n        self.header.col_ends = None\n        self.splitter = ascii.FixedWidthSplitter()\n        f = open(os.path.join(HERE, 'files', 'fixed_width', 'string.txt'))\n        self.lines = f.read().split('\\n')\n        f.close()\n        self.header.get_cols(self.lines)\n        self.splitter.cols = self.header.cols\n        self.data = ascii.FixedWidthData()",
        "name": "io_ascii.fixedwidth.FixedWidthSuite.time_header",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ab31959770db8530c2a7211c49c8d5a7db6c42b75ff8fb0bac4be7689f1837ea",
        "warmup_time": -1
    },
    "io_ascii.fixedwidth.FixedWidthSuite.time_splitter": {
        "code": "class FixedWidthSuite:\n    def time_splitter(self):\n        self.splitter(self.lines[1:])\n\n    def setup(self):\n        self.header = ascii.FixedWidthHeader()\n        self.header.start_line = 0\n        self.header.col_starts = None\n        self.header.col_ends = None\n        self.splitter = ascii.FixedWidthSplitter()\n        f = open(os.path.join(HERE, 'files', 'fixed_width', 'string.txt'))\n        self.lines = f.read().split('\\n')\n        f.close()\n        self.header.get_cols(self.lines)\n        self.splitter.cols = self.header.cols\n        self.data = ascii.FixedWidthData()",
        "name": "io_ascii.fixedwidth.FixedWidthSuite.time_splitter",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a8f2eed392691b8fede23e560b4b933aef960db35ac1dafac4857c53e839ecf0",
        "warmup_time": -1
    },
    "io_ascii.ipac.IPACSuite.time_data_str_vals": {
        "code": "class IPACSuite:\n    def time_data_str_vals(self):\n        data = IpacData()\n        data.cols = list(self.table.columns.values())\n        data.str_vals()\n\n    def setup(self):\n        self.header = IpacHeader()\n        self.data = IpacData()\n        self.header.data = self.data\n        self.splitter = IpacHeaderSplitter()\n        self.vals = [str(i + 1) for i in range(1000)]\n        self.widths = [i + 1 for i in range(1000)]\n        f = open(os.path.join(HERE, 'files', 'ipac', 'string.txt'))\n        self.lines = f.read().split('\\n')\n        f.close()\n        self.table = ascii.read(os.path.join(HERE, 'files', 'ipac', 'string.txt'),\n                                format='ipac', guess=False)",
        "name": "io_ascii.ipac.IPACSuite.time_data_str_vals",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "47e34452c6c6cea6ff597dbd27faa2d6b83a1b1e77978c28cd3482d1ee83666e",
        "warmup_time": -1
    },
    "io_ascii.ipac.IPACSuite.time_get_cols": {
        "code": "class IPACSuite:\n    def time_get_cols(self):\n        self.header.get_cols(self.lines)\n\n    def setup(self):\n        self.header = IpacHeader()\n        self.data = IpacData()\n        self.header.data = self.data\n        self.splitter = IpacHeaderSplitter()\n        self.vals = [str(i + 1) for i in range(1000)]\n        self.widths = [i + 1 for i in range(1000)]\n        f = open(os.path.join(HERE, 'files', 'ipac', 'string.txt'))\n        self.lines = f.read().split('\\n')\n        f.close()\n        self.table = ascii.read(os.path.join(HERE, 'files', 'ipac', 'string.txt'),\n                                format='ipac', guess=False)",
        "name": "io_ascii.ipac.IPACSuite.time_get_cols",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b9db559aa8e7052afe0b952515629cdc112d29661dc35db39d3ff11729eebc29",
        "warmup_time": -1
    },
    "io_ascii.ipac.IPACSuite.time_header_str_vals": {
        "code": "class IPACSuite:\n    def time_header_str_vals(self):\n        header = IpacHeader()\n        header.cols = list(self.table.columns.values())\n        header.DBMS = False\n        header.str_vals()\n\n    def setup(self):\n        self.header = IpacHeader()\n        self.data = IpacData()\n        self.header.data = self.data\n        self.splitter = IpacHeaderSplitter()\n        self.vals = [str(i + 1) for i in range(1000)]\n        self.widths = [i + 1 for i in range(1000)]\n        f = open(os.path.join(HERE, 'files', 'ipac', 'string.txt'))\n        self.lines = f.read().split('\\n')\n        f.close()\n        self.table = ascii.read(os.path.join(HERE, 'files', 'ipac', 'string.txt'),\n                                format='ipac', guess=False)",
        "name": "io_ascii.ipac.IPACSuite.time_header_str_vals",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "aa060983b5957fd31ff49679e66aefc332677decfd9212e9adbd53c00e2bfddd",
        "warmup_time": -1
    },
    "io_ascii.ipac.IPACSuite.time_splitter": {
        "code": "class IPACSuite:\n    def time_splitter(self):\n        self.splitter.join(self.vals, self.widths)\n\n    def setup(self):\n        self.header = IpacHeader()\n        self.data = IpacData()\n        self.header.data = self.data\n        self.splitter = IpacHeaderSplitter()\n        self.vals = [str(i + 1) for i in range(1000)]\n        self.widths = [i + 1 for i in range(1000)]\n        f = open(os.path.join(HERE, 'files', 'ipac', 'string.txt'))\n        self.lines = f.read().split('\\n')\n        f.close()\n        self.table = ascii.read(os.path.join(HERE, 'files', 'ipac', 'string.txt'),\n                                format='ipac', guess=False)",
        "name": "io_ascii.ipac.IPACSuite.time_splitter",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "66d8365cd4fe318c5c52d8736597f2fc458b67b38ab4e7a58e9d121340f0d372",
        "warmup_time": -1
    },
    "io_ascii.main.AastexFloat.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.AastexFloat.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.AastexFloat.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.AastexFloat.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.AastexInt.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.AastexInt.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.AastexInt.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.AastexInt.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.AastexString.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.AastexString.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.AastexString.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.AastexString.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.BasicFloat.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.BasicFloat.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.BasicFloat.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.BasicFloat.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.BasicInt.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.BasicInt.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.BasicInt.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.BasicInt.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.BasicString.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.BasicString.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.BasicString.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.BasicString.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.CommentedHeaderFloat.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.CommentedHeaderFloat.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.CommentedHeaderFloat.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.CommentedHeaderFloat.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.CommentedHeaderInt.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.CommentedHeaderInt.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.CommentedHeaderInt.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.CommentedHeaderInt.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.CommentedHeaderString.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.CommentedHeaderString.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.CommentedHeaderString.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.CommentedHeaderString.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.CsvFloat.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.CsvFloat.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.CsvFloat.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.CsvFloat.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.CsvInt.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.CsvInt.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.CsvInt.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.CsvInt.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.CsvString.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.CsvString.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.CsvString.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.CsvString.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthFloat.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthFloat.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthFloat.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthFloat.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthInt.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthInt.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthInt.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthInt.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthNoHeaderFloat.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthNoHeaderFloat.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthNoHeaderFloat.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthNoHeaderFloat.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthNoHeaderInt.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthNoHeaderInt.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthNoHeaderInt.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthNoHeaderInt.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthNoHeaderString.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthNoHeaderString.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthNoHeaderString.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthNoHeaderString.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthString.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthString.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthString.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthString.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthTwoLineFloat.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthTwoLineFloat.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthTwoLineFloat.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthTwoLineFloat.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthTwoLineInt.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthTwoLineInt.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthTwoLineInt.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthTwoLineInt.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthTwoLineString.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthTwoLineString.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.FixedWidthTwoLineString.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.FixedWidthTwoLineString.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.IpacFloat.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.IpacFloat.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.IpacFloat.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.IpacFloat.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.IpacInt.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.IpacInt.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.IpacInt.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.IpacInt.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.IpacString.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.IpacString.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.IpacString.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.IpacString.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.LatexFloat.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.LatexFloat.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.LatexFloat.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.LatexFloat.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.LatexInt.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.LatexInt.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.LatexInt.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.LatexInt.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.LatexString.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.LatexString.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.LatexString.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.LatexString.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.NoHeaderFloat.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.NoHeaderFloat.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.NoHeaderFloat.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.NoHeaderFloat.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.NoHeaderInt.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.NoHeaderInt.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.NoHeaderInt.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.NoHeaderInt.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.NoHeaderString.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.NoHeaderString.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.NoHeaderString.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.NoHeaderString.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.RdbFloat.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.RdbFloat.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.RdbFloat.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.RdbFloat.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.RdbInt.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.RdbInt.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.RdbInt.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.RdbInt.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.RdbString.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.RdbString.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.RdbString.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.RdbString.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.SextractorFloat.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.SextractorFloat.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.SextractorInt.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.SextractorInt.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.SextractorString.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.SextractorString.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.TabFloat.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.TabFloat.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.TabFloat.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.TabFloat.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.TabInt.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.TabInt.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.TabInt.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.TabInt.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.main.TabString.time_read": {
        "code": "class _ASCIISuite:\n    def read(self):\n        return ascii.read(BytesIO(self.data), format=self.file_format, guess=False)\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.TabString.time_read",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f3f98728a95e3fb54e58199096d5d7673373a44c7a7043ed8f2a66f58abfdb20",
        "warmup_time": -1
    },
    "io_ascii.main.TabString.time_write": {
        "code": "class _ASCIISuite:\n    def write(self):\n        ascii.write(self.table, self.output, Writer=self.writers[self.file_format])\n\n    def setup(self):\n        self.tables = {}\n        self.data = {}\n        self.output = StringIO()\n        self.writers = {\n            'csv': ascii.Csv,\n            'rdb': ascii.Rdb,\n            'fixed_width': ascii.FixedWidth,\n            'fixed_width_no_header': ascii.FixedWidthNoHeader,\n            'fixed_width_two_line': ascii.FixedWidthTwoLine,\n            'tab': ascii.Tab,\n            'no_header': ascii.NoHeader,\n            'commented_header': ascii.CommentedHeader,\n            'basic': ascii.Basic,\n            'ipac': ascii.Ipac,\n            'latex': ascii.Latex,\n            'aastex': ascii.AASTex\n            }\n        with io.open(os.path.join(HERE, 'files', self.file_format, '{0}.txt'.format(self.data_type)), 'rb') as f:\n            self.data = f.read()\n        if self.file_format != 'sextractor':\n            self.table = self.read()",
        "name": "io_ascii.main.TabString.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "897cf90f396ada2768dcfb8082f28f799727fefdc591208d0cebb9ef67420754",
        "warmup_time": -1
    },
    "io_ascii.rdb.RDBSuite.time_get_cols": {
        "code": "class RDBSuite:\n    def time_get_cols(self):\n        self.header.get_cols(self.lines)\n\n    def setup(self):\n        self.header = basic.RdbHeader()\n        self.header.splitter.delimiter = '\\t'\n        f = open(os.path.join(HERE,'files','rdb', 'string.txt'))\n        self.lines = f.read().split('\\n')\n        f.close()",
        "name": "io_ascii.rdb.RDBSuite.time_get_cols",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "37775e9215e57ff1ba0ec99edd94cbc2a293a129a551ed55f92e669007bad661",
        "warmup_time": -1
    },
    "io_ascii.sextractor.SExtractorSuite.time_header": {
        "code": "class SExtractorSuite:\n    def time_header(self):\n        self.header.get_cols(self.lines)\n\n    def setup(self):\n        self.header = sextractor.SExtractorHeader()\n        self.lines = []\n        i = 0\n        while i < 100000:\n            if i % 20 == 0 and i != 0:\n                i += 4\n            i += 1\n            self.lines.append('# {} {} Description [pixel**2]'.format(\n                                                        i, randword()))\n        self.lines.append('Non-header line')",
        "name": "io_ascii.sextractor.SExtractorSuite.time_header",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a9db4d189763ff1473f14cb8d568fbe618facb3d376edc5a200bf69eefc7a110",
        "warmup_time": -1
    },
    "io_ascii.table.TableSuite.mem_table_init": {
        "code": "class TableSuite:\n    def mem_table_init(self):\n        return table.Table(self.lst)\n\n    def setup(self):\n        self.lst = []\n        self.lst.append([random.randint(-500, 500) for i in range(1000)])\n        self.lst.append([random.random() * 500 - 500 for i in range(1000)])\n        self.lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, self.lst):\n            col.data = x\n        self.table_cols = [table.Column(x) for x in self.lst]\n        self.outputter = core.TableOutputter()\n        self.table = table.Table()",
        "name": "io_ascii.table.TableSuite.mem_table_init",
        "param_names": [],
        "params": [],
        "timeout": 60.0,
        "type": "memory",
        "unit": "bytes",
        "version": "f93dd63923309c0a3643cbc5565c4081d6525256c63f4845d5f94ba6e4ea0bd6"
    },
    "io_ascii.table.TableSuite.mem_table_outputter": {
        "code": "class TableSuite:\n    def mem_table_outputter(self):\n        return self.outputter(self.cols, {'table': {}})\n\n    def setup(self):\n        self.lst = []\n        self.lst.append([random.randint(-500, 500) for i in range(1000)])\n        self.lst.append([random.random() * 500 - 500 for i in range(1000)])\n        self.lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, self.lst):\n            col.data = x\n        self.table_cols = [table.Column(x) for x in self.lst]\n        self.outputter = core.TableOutputter()\n        self.table = table.Table()",
        "name": "io_ascii.table.TableSuite.mem_table_outputter",
        "param_names": [],
        "params": [],
        "timeout": 60.0,
        "type": "memory",
        "unit": "bytes",
        "version": "0ee6f7a393d03abd1ac6cdfa55936a4462adde546042fddc5ba7189476e0507b"
    },
    "io_ascii.table.TableSuite.time_str_vals_float": {
        "code": "class TableSuite:\n    def time_str_vals_float(self):\n        self.table_cols[1].iter_str_vals()\n\n    def setup(self):\n        self.lst = []\n        self.lst.append([random.randint(-500, 500) for i in range(1000)])\n        self.lst.append([random.random() * 500 - 500 for i in range(1000)])\n        self.lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, self.lst):\n            col.data = x\n        self.table_cols = [table.Column(x) for x in self.lst]\n        self.outputter = core.TableOutputter()\n        self.table = table.Table()",
        "name": "io_ascii.table.TableSuite.time_str_vals_float",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2d818883f1301a824cb3809cdc36587446e6edba5a2fcb67f00410e94f731669",
        "warmup_time": -1
    },
    "io_ascii.table.TableSuite.time_str_vals_int": {
        "code": "class TableSuite:\n    def time_str_vals_int(self):\n        self.table_cols[0].iter_str_vals()\n\n    def setup(self):\n        self.lst = []\n        self.lst.append([random.randint(-500, 500) for i in range(1000)])\n        self.lst.append([random.random() * 500 - 500 for i in range(1000)])\n        self.lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, self.lst):\n            col.data = x\n        self.table_cols = [table.Column(x) for x in self.lst]\n        self.outputter = core.TableOutputter()\n        self.table = table.Table()",
        "name": "io_ascii.table.TableSuite.time_str_vals_int",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9109ab1ddedde92cafdb2a0644f73936b59cd52b967369db71cbf0532cd65d46",
        "warmup_time": -1
    },
    "io_ascii.table.TableSuite.time_str_vals_str": {
        "code": "class TableSuite:\n    def time_str_vals_str(self):\n        self.table_cols[2].iter_str_vals()\n\n    def setup(self):\n        self.lst = []\n        self.lst.append([random.randint(-500, 500) for i in range(1000)])\n        self.lst.append([random.random() * 500 - 500 for i in range(1000)])\n        self.lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, self.lst):\n            col.data = x\n        self.table_cols = [table.Column(x) for x in self.lst]\n        self.outputter = core.TableOutputter()\n        self.table = table.Table()",
        "name": "io_ascii.table.TableSuite.time_str_vals_str",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "854ab35dbba7720bbe4729cc5ca9aaf04d856af1f4e0d32f1c7c7504f29a46f8",
        "warmup_time": -1
    },
    "io_ascii.table.TableSuite.time_table_init_from_list": {
        "code": "class TableSuite:\n    def time_table_init_from_list(self):\n        self.table._init_from_list(self.table_cols, ['1', '2', '3'],\n                                   [None, None, None], 3, True)\n\n    def setup(self):\n        self.lst = []\n        self.lst.append([random.randint(-500, 500) for i in range(1000)])\n        self.lst.append([random.random() * 500 - 500 for i in range(1000)])\n        self.lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, self.lst):\n            col.data = x\n        self.table_cols = [table.Column(x) for x in self.lst]\n        self.outputter = core.TableOutputter()\n        self.table = table.Table()",
        "name": "io_ascii.table.TableSuite.time_table_init_from_list",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ebc1f5751e08f92ba669a08cb5144ce1c72d750daf659f9e933b18c5fcf92d69",
        "warmup_time": -1
    },
    "io_ascii.table.TableSuite.time_table_outputter": {
        "code": "class TableSuite:\n    def time_table_outputter(self):\n        self.outputter(self.cols, {'table': {}})\n\n    def setup(self):\n        self.lst = []\n        self.lst.append([random.randint(-500, 500) for i in range(1000)])\n        self.lst.append([random.random() * 500 - 500 for i in range(1000)])\n        self.lst.append([''.join([random.choice(uppercase) for j in\n                            range(6)]) for i in range(1000)])\n        self.cols = [core.Column(str(i + 1)) for i in range(3)]\n        for col, x in izip(self.cols, self.lst):\n            col.data = x\n        self.table_cols = [table.Column(x) for x in self.lst]\n        self.outputter = core.TableOutputter()\n        self.table = table.Table()",
        "name": "io_ascii.table.TableSuite.time_table_outputter",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c9cda8c5462696d451d132a464ef7a0319161924c36a82031904e8c6a0b7fd9b",
        "warmup_time": -1
    },
    "io_fits.FITSBinTableHDU.time_from_columns_bytes": {
        "code": "class FITSBinTableHDU:\n    def time_from_columns_bytes(self):\n        x = np.repeat(b'a', 2_000_000)\n        array = np.array(x, dtype=[('col', 'S1')])\n        BinTableHDU.from_columns(array)",
        "name": "io_fits.FITSBinTableHDU.time_from_columns_bytes",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0ced98097e668afc55cb7c214f0ec629dac253341826ca667d7fb28428f6db1a",
        "warmup_time": -1
    },
    "io_fits.FITSHighLevelTableBenchmarks.time_read_nommap": {
        "code": "class FITSHighLevelTableBenchmarks:\n    def time_read_nommap(self):\n        self.table_bytes.seek(0)\n        try:\n            Table.read(self.table_bytes, format='fits', memmap=False)\n        except TypeError:\n            Table.read(self.table_bytes, format='fits')\n\n    def setup(self):\n    \n        N = 2_000_000\n    \n        self.table_bytes = BytesIO()\n    \n        t = Table()\n        t['floats'] = np.random.random(N)\n        t['ints'] = np.random.randint(0, 100, N)\n        t['strings'] = b'some strings'\n        t['booleans'] = t['floats'] > 0.5\n        t.write(self.table_bytes, format='fits')",
        "name": "io_fits.FITSHighLevelTableBenchmarks.time_read_nommap",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "aad5f871ef8603c05f0a64ae405c585e95d081798cb3576da10a6bd73d17d3bf",
        "warmup_time": -1
    },
    "io_fits.FITSHighLevelTableBenchmarks.time_write": {
        "code": "class FITSHighLevelTableBenchmarks:\n    def time_write(self):\n        N = 1_000_000\n        table_bytes = BytesIO()\n        t = Table()\n        t['floats'] = np.random.random(N)\n        t['ints'] = np.random.randint(0, 100, N)\n        t['strings'] = b'some strings'\n        t['booleans'] = t['floats'] > 0.5\n        t.write(table_bytes, format='fits')\n\n    def setup(self):\n    \n        N = 2_000_000\n    \n        self.table_bytes = BytesIO()\n    \n        t = Table()\n        t['floats'] = np.random.random(N)\n        t['ints'] = np.random.randint(0, 100, N)\n        t['strings'] = b'some strings'\n        t['booleans'] = t['floats'] > 0.5\n        t.write(self.table_bytes, format='fits')",
        "name": "io_fits.FITSHighLevelTableBenchmarks.time_write",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "dbe7f96c19284a4c494c1f35313cd7f12a367d222c3dffb9c45dab2372722556",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_add_column": {
        "code": "class TimeTable:\n    def time_add_column(self):\n        self.table['e'] = self.extra_column\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_add_column",
        "number": 1,
        "param_names": [],
        "params": [],
        "repeat": 1,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b2c0ad0af05e6ff645357e4e21fbb3c31b647579f850c111c9494b69fecab587",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_add_row": {
        "code": "class TimeTable:\n    def time_add_row(self):\n        self.table.add_row(self.extra_row)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_add_row",
        "number": 1,
        "param_names": [],
        "params": [],
        "repeat": 1,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c3da92e8384276af12dd0b284b378baea2170c58c83b6d61874804cd715d6a5f",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_aggregate": {
        "code": "class TimeTable:\n    def time_aggregate(self):\n        # Test aggregate with a function that supports reduceat\n        self.table_grouped.groups.aggregate(np.sum)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_aggregate",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d87a6eadd3a4c94d95d33449d19c6c00474eeb1ada4b13633a28ec4e47eb57f6",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_aggregate_noreduceat": {
        "code": "class TimeTable:\n    def time_aggregate_noreduceat(self):\n        # Test aggregate with a function that doesn't support reduceat\n        self.table_grouped.groups.aggregate(lambda x: np.sum(x))\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_aggregate_noreduceat",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6607870ad7344f17d4ccea4ca0a86ce464eeccd21fe98d970ff2c699f03c7e17",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_column_get": {
        "code": "class TimeTable:\n    def time_column_get(self):\n        self.table['c']\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_column_get",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f863a90229743a65604d98100febf2400d345032ae27cbd7f0450db596a88956",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_column_make_bool_mask": {
        "code": "class TimeTable:\n    def time_column_make_bool_mask(self):\n        self.table['a'] > 0.6\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_column_make_bool_mask",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6dfae7f99d875b90ce8bb45b2232e8c9448734810edacf42fcafd45e522d1ff0",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_column_set": {
        "code": "class TimeTable:\n    def time_column_set(self):\n        self.table['a'] = 0.\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_column_set",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3b94497b8947080e3a7ad68c0d27b547fda203e3a82a6f9aef412c5b38553ce2",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_column_set_all": {
        "code": "class TimeTable:\n    def time_column_set_all(self):\n        self.table['b'][:] = True\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_column_set_all",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "42a14616589c8ebefc8d09c74be3c4b4081dc5025fc1dc68c45b04046129c898",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_column_set_row_subset": {
        "code": "class TimeTable:\n    def time_column_set_row_subset(self):\n        self.table['b'][self.bool_mask] = True\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_column_set_row_subset",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f5286a927031d2e4c72969b4294ad326f835625ffff8cab42d5a0fb0fc66d5fc",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_column_set_row_subset_int": {
        "code": "class TimeTable:\n    def time_column_set_row_subset_int(self):\n        self.table['b'][self.row_indices] = True\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_column_set_row_subset_int",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7a46311bfa2b1cc228c79ef31d83d80d7211b6f720c0efc76645408ecb0cc88b",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_column_slice_bool": {
        "code": "class TimeTable:\n    def time_column_slice_bool(self):\n        col_subset = self.table['a'][self.bool_mask]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_column_slice_bool",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "606fa21ee4fae7dd015b43a97a9d3ba938acd3ba1c2b34262dd6bf6d51f33f54",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_column_slice_int": {
        "code": "class TimeTable:\n    def time_column_slice_int(self):\n        col_subset = self.table['a'][self.row_indices]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_column_slice_int",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1d1818da027642ddf329e814913cf0be71476438e4a90444aa085d5f92f6fbe2",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_copy_column": {
        "code": "class TimeTable:\n    def time_copy_column(self):\n        self.table['a'].copy()\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_copy_column",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f1684c651fd087a764de4d038893b4c9610489a81f8162fa217742e1a0921bff",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_copy_table": {
        "code": "class TimeTable:\n    def time_copy_table(self):\n        self.table.copy()\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_copy_table",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9dfee0ffd435859c66c9d478df0b81fb8b7497a2a81897f10c557f39f695c328",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_group": {
        "code": "class TimeTable:\n    def time_group(self):\n        self.table.group_by('d')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_group",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "00833c0817e383400bfaa81fbed6cd67f6bf8e38ab39dad34bf18acb12eb6240",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_hstack": {
        "code": "class TimeTable:\n    def time_hstack(self):\n        hstack([self.table, self.other_table_2])\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_hstack",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0bb53b6f70a1c0e044582584e8e4e16e12b0a6d2de3a8031520e683f725548a0",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_init_from_np_array_copy": {
        "code": "class TimeTable:\n    def time_init_from_np_array_copy(self):\n        Table(self.np_table, copy=True)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_init_from_np_array_copy",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4336289776445bd679565fab2aff50641d5bb4d8e1f21f2c8d37a26af69f59f8",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_init_from_np_array_no_copy": {
        "code": "class TimeTable:\n    def time_init_from_np_array_no_copy(self):\n        Table(self.np_table, copy=False)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_init_from_np_array_no_copy",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b13e3a0b7c95d73514fa4353bd5e2fc362b0a2133200cfbca7578616000b7c88",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_item_get_colfirst": {
        "code": "class TimeTable:\n    def time_item_get_colfirst(self):\n        self.table['b'][300]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_item_get_colfirst",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0dd32efbfedd563aa310767ea5c4ed044e744ee7a4fbbd06b2d67f39b0646c2a",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_item_get_rowfirst": {
        "code": "class TimeTable:\n    def time_item_get_rowfirst(self):\n        self.table[300]['b']\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_item_get_rowfirst",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "09093997db41771a090f840eefd60e7d2577c519a976b9b88d799aa21d242a1b",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_iter_row": {
        "code": "class TimeTable:\n    def time_iter_row(self):\n        for row in self.table:\n            pass\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_iter_row",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5c031f2eb8938c243423fa5dabd4c66ced4063a63b583bd3f54270bc1f211fae",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_join_inner": {
        "code": "class TimeTable:\n    def time_join_inner(self):\n        join(self.table, self.other_table, keys=\"i\", join_type='inner')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_join_inner",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0c28429345963649f5df731dce5bbd22588b0f465f5112c20ac6e8fc367697c7",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_join_outer": {
        "code": "class TimeTable:\n    def time_join_outer(self):\n        join(self.table, self.other_table, keys=\"i\", join_type='outer')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_join_outer",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4c3bf2e6aaf0b0fa9873b63128ace026c611e846f2b72ceb1c4a7170dd790984",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_mask_column": {
        "code": "class TimeMaskedTable:\n    def time_mask_column(self):\n        self.table['a'].mask = self.bool_mask\n\nclass TimeTable:\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_mask_column",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8199306b947c7320fcf35aa5e9c87146b8bb91f9cba9d25fb9290a8ff006cee7",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_multi_column_get": {
        "code": "class TimeTable:\n    def time_multi_column_get(self):\n        self.table[('a','c')]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_multi_column_get",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f078ef4c7d77390944802d30e7ef0381d6372c9dd211c3bb6163265eb8a8a0d9",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_read_rows": {
        "code": "class TimeTable:\n    def time_read_rows(self):\n        for row in self.table:\n            tuple(row)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_read_rows",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b8c9879da2aac0e2ec1225c2f64e3b30c8ca22ad100b1eea118285204166f604",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_remove_column": {
        "code": "class TimeTable:\n    def time_remove_column(self):\n        self.table.remove_column('a')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_remove_column",
        "number": 1,
        "param_names": [],
        "params": [],
        "repeat": 1,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ac775b1968a61183af601e5a5ebd1443c52d1e28bdb86520ac2fef19d4c38088",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_remove_row": {
        "code": "class TimeTable:\n    def time_remove_row(self):\n        self.table.remove_row(6)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_remove_row",
        "number": 1,
        "param_names": [],
        "params": [],
        "repeat": 1,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a649c857c45262e8ad834755d02de13041d4fc893ecc1a30d7297f4c36541290",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_remove_rows": {
        "code": "class TimeTable:\n    def time_remove_rows(self):\n        self.table.remove_rows(self.row_indices)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_remove_rows",
        "number": 1,
        "param_names": [],
        "params": [],
        "repeat": 1,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1b7c4ed8b6c2a92d93e9b2ce007c596b7c79317f1427056e26f65f9873a510ef",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_row_get": {
        "code": "class TimeTable:\n    def time_row_get(self):\n        self.table[300]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_row_get",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "045657db9d7ef5938a36c9885c2627d0a0a8806f51a24693858d11245a8641b0",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_sort": {
        "code": "class TimeTable:\n    def time_sort(self):\n        self.table.sort('a')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_sort",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c5563d6c2ba316f51667e1e02e88372d03a0d46ce635fcf28c99a19b8a47f364",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_table_slice_bool": {
        "code": "class TimeTable:\n    def time_table_slice_bool(self):\n        table_subset = self.table[self.bool_mask]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_table_slice_bool",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "aa3e39b38985bb5ece815375cfeeac330868d465afe58025e987d4e6ee7b6f16",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_table_slice_int": {
        "code": "class TimeTable:\n    def time_table_slice_int(self):\n        table_subset = self.table[self.row_indices]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_table_slice_int",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d371f5b0e33a94248be0e224cef150f53d07c64f2e16111a308b57b90ad93080",
        "warmup_time": -1
    },
    "table.TimeMaskedTable.time_vstack": {
        "code": "class TimeTable:\n    def time_vstack(self):\n        vstack([self.table, self.table])\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeMaskedTable.time_vstack",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "398d840ff2c40a226540b887b02f1c56020693a589a7526505fd59479cc7256b",
        "warmup_time": -1
    },
    "table.TimeTable.time_add_column": {
        "code": "class TimeTable:\n    def time_add_column(self):\n        self.table['e'] = self.extra_column\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_add_column",
        "number": 1,
        "param_names": [],
        "params": [],
        "repeat": 1,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b2c0ad0af05e6ff645357e4e21fbb3c31b647579f850c111c9494b69fecab587",
        "warmup_time": -1
    },
    "table.TimeTable.time_add_row": {
        "code": "class TimeTable:\n    def time_add_row(self):\n        self.table.add_row(self.extra_row)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_add_row",
        "number": 1,
        "param_names": [],
        "params": [],
        "repeat": 1,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c3da92e8384276af12dd0b284b378baea2170c58c83b6d61874804cd715d6a5f",
        "warmup_time": -1
    },
    "table.TimeTable.time_aggregate": {
        "code": "class TimeTable:\n    def time_aggregate(self):\n        # Test aggregate with a function that supports reduceat\n        self.table_grouped.groups.aggregate(np.sum)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_aggregate",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d87a6eadd3a4c94d95d33449d19c6c00474eeb1ada4b13633a28ec4e47eb57f6",
        "warmup_time": -1
    },
    "table.TimeTable.time_aggregate_noreduceat": {
        "code": "class TimeTable:\n    def time_aggregate_noreduceat(self):\n        # Test aggregate with a function that doesn't support reduceat\n        self.table_grouped.groups.aggregate(lambda x: np.sum(x))\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_aggregate_noreduceat",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6607870ad7344f17d4ccea4ca0a86ce464eeccd21fe98d970ff2c699f03c7e17",
        "warmup_time": -1
    },
    "table.TimeTable.time_column_get": {
        "code": "class TimeTable:\n    def time_column_get(self):\n        self.table['c']\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_column_get",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f863a90229743a65604d98100febf2400d345032ae27cbd7f0450db596a88956",
        "warmup_time": -1
    },
    "table.TimeTable.time_column_make_bool_mask": {
        "code": "class TimeTable:\n    def time_column_make_bool_mask(self):\n        self.table['a'] > 0.6\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_column_make_bool_mask",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6dfae7f99d875b90ce8bb45b2232e8c9448734810edacf42fcafd45e522d1ff0",
        "warmup_time": -1
    },
    "table.TimeTable.time_column_set": {
        "code": "class TimeTable:\n    def time_column_set(self):\n        self.table['a'] = 0.\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_column_set",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3b94497b8947080e3a7ad68c0d27b547fda203e3a82a6f9aef412c5b38553ce2",
        "warmup_time": -1
    },
    "table.TimeTable.time_column_set_all": {
        "code": "class TimeTable:\n    def time_column_set_all(self):\n        self.table['b'][:] = True\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_column_set_all",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "42a14616589c8ebefc8d09c74be3c4b4081dc5025fc1dc68c45b04046129c898",
        "warmup_time": -1
    },
    "table.TimeTable.time_column_set_row_subset": {
        "code": "class TimeTable:\n    def time_column_set_row_subset(self):\n        self.table['b'][self.bool_mask] = True\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_column_set_row_subset",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f5286a927031d2e4c72969b4294ad326f835625ffff8cab42d5a0fb0fc66d5fc",
        "warmup_time": -1
    },
    "table.TimeTable.time_column_set_row_subset_int": {
        "code": "class TimeTable:\n    def time_column_set_row_subset_int(self):\n        self.table['b'][self.row_indices] = True\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_column_set_row_subset_int",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7a46311bfa2b1cc228c79ef31d83d80d7211b6f720c0efc76645408ecb0cc88b",
        "warmup_time": -1
    },
    "table.TimeTable.time_column_slice_bool": {
        "code": "class TimeTable:\n    def time_column_slice_bool(self):\n        col_subset = self.table['a'][self.bool_mask]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_column_slice_bool",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "606fa21ee4fae7dd015b43a97a9d3ba938acd3ba1c2b34262dd6bf6d51f33f54",
        "warmup_time": -1
    },
    "table.TimeTable.time_column_slice_int": {
        "code": "class TimeTable:\n    def time_column_slice_int(self):\n        col_subset = self.table['a'][self.row_indices]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_column_slice_int",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1d1818da027642ddf329e814913cf0be71476438e4a90444aa085d5f92f6fbe2",
        "warmup_time": -1
    },
    "table.TimeTable.time_copy_column": {
        "code": "class TimeTable:\n    def time_copy_column(self):\n        self.table['a'].copy()\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_copy_column",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f1684c651fd087a764de4d038893b4c9610489a81f8162fa217742e1a0921bff",
        "warmup_time": -1
    },
    "table.TimeTable.time_copy_table": {
        "code": "class TimeTable:\n    def time_copy_table(self):\n        self.table.copy()\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_copy_table",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9dfee0ffd435859c66c9d478df0b81fb8b7497a2a81897f10c557f39f695c328",
        "warmup_time": -1
    },
    "table.TimeTable.time_group": {
        "code": "class TimeTable:\n    def time_group(self):\n        self.table.group_by('d')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_group",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "00833c0817e383400bfaa81fbed6cd67f6bf8e38ab39dad34bf18acb12eb6240",
        "warmup_time": -1
    },
    "table.TimeTable.time_hstack": {
        "code": "class TimeTable:\n    def time_hstack(self):\n        hstack([self.table, self.other_table_2])\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_hstack",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0bb53b6f70a1c0e044582584e8e4e16e12b0a6d2de3a8031520e683f725548a0",
        "warmup_time": -1
    },
    "table.TimeTable.time_init_from_np_array_copy": {
        "code": "class TimeTable:\n    def time_init_from_np_array_copy(self):\n        Table(self.np_table, copy=True)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_init_from_np_array_copy",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4336289776445bd679565fab2aff50641d5bb4d8e1f21f2c8d37a26af69f59f8",
        "warmup_time": -1
    },
    "table.TimeTable.time_init_from_np_array_no_copy": {
        "code": "class TimeTable:\n    def time_init_from_np_array_no_copy(self):\n        Table(self.np_table, copy=False)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_init_from_np_array_no_copy",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b13e3a0b7c95d73514fa4353bd5e2fc362b0a2133200cfbca7578616000b7c88",
        "warmup_time": -1
    },
    "table.TimeTable.time_item_get_colfirst": {
        "code": "class TimeTable:\n    def time_item_get_colfirst(self):\n        self.table['b'][300]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_item_get_colfirst",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0dd32efbfedd563aa310767ea5c4ed044e744ee7a4fbbd06b2d67f39b0646c2a",
        "warmup_time": -1
    },
    "table.TimeTable.time_item_get_rowfirst": {
        "code": "class TimeTable:\n    def time_item_get_rowfirst(self):\n        self.table[300]['b']\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_item_get_rowfirst",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "09093997db41771a090f840eefd60e7d2577c519a976b9b88d799aa21d242a1b",
        "warmup_time": -1
    },
    "table.TimeTable.time_iter_row": {
        "code": "class TimeTable:\n    def time_iter_row(self):\n        for row in self.table:\n            pass\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_iter_row",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5c031f2eb8938c243423fa5dabd4c66ced4063a63b583bd3f54270bc1f211fae",
        "warmup_time": -1
    },
    "table.TimeTable.time_join_inner": {
        "code": "class TimeTable:\n    def time_join_inner(self):\n        join(self.table, self.other_table, keys=\"i\", join_type='inner')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_join_inner",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0c28429345963649f5df731dce5bbd22588b0f465f5112c20ac6e8fc367697c7",
        "warmup_time": -1
    },
    "table.TimeTable.time_join_outer": {
        "code": "class TimeTable:\n    def time_join_outer(self):\n        join(self.table, self.other_table, keys=\"i\", join_type='outer')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_join_outer",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4c3bf2e6aaf0b0fa9873b63128ace026c611e846f2b72ceb1c4a7170dd790984",
        "warmup_time": -1
    },
    "table.TimeTable.time_multi_column_get": {
        "code": "class TimeTable:\n    def time_multi_column_get(self):\n        self.table[('a','c')]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_multi_column_get",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f078ef4c7d77390944802d30e7ef0381d6372c9dd211c3bb6163265eb8a8a0d9",
        "warmup_time": -1
    },
    "table.TimeTable.time_read_rows": {
        "code": "class TimeTable:\n    def time_read_rows(self):\n        for row in self.table:\n            tuple(row)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_read_rows",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b8c9879da2aac0e2ec1225c2f64e3b30c8ca22ad100b1eea118285204166f604",
        "warmup_time": -1
    },
    "table.TimeTable.time_remove_column": {
        "code": "class TimeTable:\n    def time_remove_column(self):\n        self.table.remove_column('a')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_remove_column",
        "number": 1,
        "param_names": [],
        "params": [],
        "repeat": 1,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ac775b1968a61183af601e5a5ebd1443c52d1e28bdb86520ac2fef19d4c38088",
        "warmup_time": -1
    },
    "table.TimeTable.time_remove_row": {
        "code": "class TimeTable:\n    def time_remove_row(self):\n        self.table.remove_row(6)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_remove_row",
        "number": 1,
        "param_names": [],
        "params": [],
        "repeat": 1,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a649c857c45262e8ad834755d02de13041d4fc893ecc1a30d7297f4c36541290",
        "warmup_time": -1
    },
    "table.TimeTable.time_remove_rows": {
        "code": "class TimeTable:\n    def time_remove_rows(self):\n        self.table.remove_rows(self.row_indices)\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_remove_rows",
        "number": 1,
        "param_names": [],
        "params": [],
        "repeat": 1,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1b7c4ed8b6c2a92d93e9b2ce007c596b7c79317f1427056e26f65f9873a510ef",
        "warmup_time": -1
    },
    "table.TimeTable.time_row_get": {
        "code": "class TimeTable:\n    def time_row_get(self):\n        self.table[300]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_row_get",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "045657db9d7ef5938a36c9885c2627d0a0a8806f51a24693858d11245a8641b0",
        "warmup_time": -1
    },
    "table.TimeTable.time_sort": {
        "code": "class TimeTable:\n    def time_sort(self):\n        self.table.sort('a')\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_sort",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c5563d6c2ba316f51667e1e02e88372d03a0d46ce635fcf28c99a19b8a47f364",
        "warmup_time": -1
    },
    "table.TimeTable.time_table_slice_bool": {
        "code": "class TimeTable:\n    def time_table_slice_bool(self):\n        table_subset = self.table[self.bool_mask]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_table_slice_bool",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "aa3e39b38985bb5ece815375cfeeac330868d465afe58025e987d4e6ee7b6f16",
        "warmup_time": -1
    },
    "table.TimeTable.time_table_slice_int": {
        "code": "class TimeTable:\n    def time_table_slice_int(self):\n        table_subset = self.table[self.row_indices]\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_table_slice_int",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d371f5b0e33a94248be0e224cef150f53d07c64f2e16111a308b57b90ad93080",
        "warmup_time": -1
    },
    "table.TimeTable.time_vstack": {
        "code": "class TimeTable:\n    def time_vstack(self):\n        vstack([self.table, self.table])\n\n    def setup(self):\n    \n        # Initialize table\n        self.table = Table(masked=self.masked)\n    \n        # Create column with mixed types\n        np.random.seed(12345)\n        self.table['i'] = np.arange(1000)\n        self.table['a'] = np.random.random(1000)  # float\n        self.table['b'] = np.random.random(1000) > 0.5  # bool\n        self.table['c'] = np.random.random((1000,10))  # 2d column\n        self.table['d'] = np.random.choice(np.array(list(string.ascii_letters)),1000)\n    \n        self.np_table = np.array(self.table)\n    \n        self.extra_row = {'a':1.2, 'b':True, 'c':np.repeat(1, 10), 'd': 'Z'}\n    \n        self.extra_column = np.random.randint(0, 100, 1000)\n    \n        self.row_indices = np.where(self.table['a'] > 0.9)[0]\n    \n        self.table_grouped = self.table.group_by('d')\n    \n        # Another table for testing joining\n        self.other_table = Table(masked=self.masked)\n        self.other_table['i'] = np.arange(1,1000,3)\n        self.other_table['f'] = np.random.random()\n        self.other_table.sort('f')\n    \n        # Another table for testing hstack\n        self.other_table_2 = Table(masked=self.masked)\n        self.other_table_2['g'] = np.random.random(1000)\n        self.other_table_2['h'] = np.random.random((1000, 10))\n    \n        self.bool_mask = self.table['a'] > 0.6",
        "name": "table.TimeTable.time_vstack",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "398d840ff2c40a226540b887b02f1c56020693a589a7526505fd59479cc7256b",
        "warmup_time": -1
    },
    "units.mem_unit": {
        "code": "def mem_unit():\n    return u.erg",
        "name": "units.mem_unit",
        "param_names": [],
        "params": [],
        "timeout": 60.0,
        "type": "memory",
        "unit": "bytes",
        "version": "3a897822d63f1fc4ebc8b6f605d236642698676d05ca2a2f415a55cee964d2b8"
    },
    "units.time_compose_complex": {
        "code": "def time_compose_complex():\n    # Composing a complex unit can be very inefficient\n    (u.kg / u.s ** 3 * u.au ** 2.5 / u.yr ** 0.5 / u.sr ** 2).compose()",
        "name": "units.time_compose_complex",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "52ea1360a73607e97f50ceef1e3f3e3e848ad83b0b5362a19e4aa3fb3dceca04",
        "warmup_time": -1
    },
    "units.time_compose_to_bases": {
        "code": "def time_compose_to_bases():\n    x = copy.copy(u.Ry)\n    x.cgs",
        "name": "units.time_compose_to_bases",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "efa81d39b97d426d435dbe325a091874c13cd833db4885fd5e9e1ec35b231e35",
        "warmup_time": -1
    },
    "units.time_quantity_array_conversion": {
        "code": "def time_quantity_array_conversion():\n    (a * u.m / u.s).to(u.km / u.hour)",
        "name": "units.time_quantity_array_conversion",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "453720a338fd6209fec908aeca1d32fd167c1889d2cf194fb9cc93798ba4f918",
        "warmup_time": -1
    },
    "units.time_quantity_creation": {
        "code": "def time_quantity_creation():\n    u.Quantity(a, u.m)",
        "name": "units.time_quantity_creation",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "57da636a893f32b10c058bef66b505734774f0254e5ec31d8102670ea3749ba1",
        "warmup_time": -1
    },
    "units.time_quantity_creation_nocopy": {
        "code": "def time_quantity_creation_nocopy():\n    u.Quantity(a, u.m, copy=False)",
        "name": "units.time_quantity_creation_nocopy",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1b32a659e9bbcfc671c6339f519316d7f3586bf52e9adfff2524d9ed7c3efe92",
        "warmup_time": -1
    },
    "units.time_quantity_init_array": {
        "code": "def time_quantity_init_array():\n    a * u.m / u.s",
        "name": "units.time_quantity_init_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "957f8f9cf4974efcf01e8818e1f02c7f19f8d19c00d1a379e4038026c1a12d44",
        "warmup_time": -1
    },
    "units.time_quantity_init_scalar": {
        "code": "def time_quantity_init_scalar():\n    3. * u.m / u.s",
        "name": "units.time_quantity_init_scalar",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1f7132881f0240f773268d410a62cf9914eff40bd73ad1fd726217c1fb31dc3e",
        "warmup_time": -1
    },
    "units.time_quantity_scalar_conversion": {
        "code": "def time_quantity_scalar_conversion():\n    (3. * u.m / u.s).to(u.km / u.hour)",
        "name": "units.time_quantity_scalar_conversion",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0bc23b508de4b7bbd0fe029aa99741c170acb5975e60e82d95df92c5c4ae0a94",
        "warmup_time": -1
    },
    "units.time_quantity_times_quantity": {
        "code": "def time_quantity_times_quantity():\n    q1 * q0",
        "name": "units.time_quantity_times_quantity",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "33b450d74c52eb7359c2d056eff45d449f4158a1a0c433bd7a4ab035544b3344",
        "warmup_time": -1
    },
    "units.time_quantity_times_unit": {
        "code": "def time_quantity_times_unit():\n    q1 * u.m",
        "name": "units.time_quantity_times_unit",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "18101a547d2f59990d20d563f3734a998e00684852452c7778f2425883693063",
        "warmup_time": -1
    },
    "units.time_quantity_ufunc_sin": {
        "code": "def time_quantity_ufunc_sin():\n    np.sin(q2)",
        "name": "units.time_quantity_ufunc_sin",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6782df2b41ecd8117cefb86c1097ead62fbc89a35d3b19a64b90f3036ea24e15",
        "warmup_time": -1
    },
    "units.time_quantity_view": {
        "code": "def time_quantity_view():\n    q1.view(u.Quantity)",
        "name": "units.time_quantity_view",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "26ddf3059fc7b8c7c4410ec065066c9f1d29eee90d7da6033ef7fd194dc03c0e",
        "warmup_time": -1
    },
    "units.time_simple_unit_parse": {
        "code": "def time_simple_unit_parse():\n    u.Unit('1 d')",
        "name": "units.time_simple_unit_parse",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "18937913b36f94725f1c97a07a4783897c64f748e4ca3438d8a366ec405ff794",
        "warmup_time": -1
    },
    "units.time_unit_compose": {
        "code": "def time_unit_compose():\n    u.Ry.compose()",
        "name": "units.time_unit_compose",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c411870dd43a755992fbca4dc50586233a3eb250670f7ecd6e3861bdc3713d04",
        "warmup_time": -1
    },
    "units.time_unit_parse": {
        "code": "def time_unit_parse():\n    u.Unit('1e-07 kg m2 / s2')",
        "name": "units.time_unit_parse",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "197b3554fa4d3e39fa3aae6a308abe51ad542092cad5f0868867bc8fa021781f",
        "warmup_time": -1
    },
    "units.time_unit_to": {
        "code": "def time_unit_to():\n    u.m.to(u.pc)",
        "name": "units.time_unit_to",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6da60807eb0884de058d60357ad655c1d2db3bae2d58d75ddbc21222a2210610",
        "warmup_time": -1
    },
    "units.time_very_simple_unit_parse": {
        "code": "def time_very_simple_unit_parse():\n    u.Unit('d')",
        "name": "units.time_very_simple_unit_parse",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "21b39993087943b0334e5ed6ac90834c28d709457c414dde5c53f37387b41fdf",
        "warmup_time": -1
    },
    "version": 1,
    "visualization.wcsaxes.time_basic_plot": {
        "code": "def time_basic_plot():\n\n    fig = Figure()\n    canvas = FigureCanvas(fig)\n\n    ax = WCSAxes(fig, [0.15, 0.15, 0.7, 0.7], wcs=MSX_WCS)\n    fig.add_axes(ax)\n\n    ax.set_xlim(-0.5, 148.5)\n    ax.set_ylim(-0.5, 148.5)\n\n    canvas.draw()",
        "name": "visualization.wcsaxes.time_basic_plot",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7ec5695860cae34277828c35c0b049fd50bffd8ae413a6e3db7d7f934f1843db",
        "warmup_time": -1
    },
    "visualization.wcsaxes.time_basic_plot_with_grid": {
        "code": "def time_basic_plot_with_grid():\n\n    fig = Figure()\n    canvas = FigureCanvas(fig)\n\n    ax = WCSAxes(fig, [0.15, 0.15, 0.7, 0.7], wcs=MSX_WCS)\n    fig.add_axes(ax)\n\n    ax.grid(color='red', alpha=0.5, linestyle='solid')\n\n    ax.set_xlim(-0.5, 148.5)\n    ax.set_ylim(-0.5, 148.5)\n\n    canvas.draw()",
        "name": "visualization.wcsaxes.time_basic_plot_with_grid",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "27a3a0412eced0052cba10bab2b0ac3f13129808dfac0dc0ebaa1d469475412d",
        "warmup_time": -1
    },
    "visualization.wcsaxes.time_basic_plot_with_grid_and_overlay": {
        "code": "def time_basic_plot_with_grid_and_overlay():\n\n    fig = Figure()\n    canvas = FigureCanvas(fig)\n\n    ax = WCSAxes(fig, [0.15, 0.15, 0.7, 0.7], wcs=MSX_WCS)\n    fig.add_axes(ax)\n\n    ax.grid(color='red', alpha=0.5, linestyle='solid')\n\n    ax.set_xlim(-0.5, 148.5)\n    ax.set_ylim(-0.5, 148.5)\n\n    overlay = ax.get_coords_overlay('fk5')\n    overlay.grid(color='purple', ls='dotted')\n\n    canvas.draw()",
        "name": "visualization.wcsaxes.time_basic_plot_with_grid_and_overlay",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "sample_time": 0.1,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "af06e413366d2baecf8ed41973c1c393c8ac99f49857791375ebbbcd51e9785e",
        "warmup_time": -1
    }
}